/**
 * Translation Bundler
 * 
 * Handles bundling of translation files from the dictionary directory
 * into JSON files that can be consumed by the application.
 */

import * as fs from 'fs';
import * as path from 'path';

export class TranslationBundler {
  private dictionaryDir: string;
  private outputDir: string;
  private locales: string[];

  constructor(dictionaryDir: string, outputDir: string) {
    this.dictionaryDir = dictionaryDir;
    this.outputDir = outputDir;
    this.locales = this.getAvailableLocales();
  }

  /**
   * Get list of available locales from dictionary directory
   */
  private getAvailableLocales(): string[] {
    try {
      if (!fs.existsSync(this.dictionaryDir)) {
        console.warn(`Dictionary directory not found: ${this.dictionaryDir}`);
        return [];
      }

      return fs.readdirSync(this.dictionaryDir).filter(item => 
        fs.statSync(path.join(this.dictionaryDir, item)).isDirectory()
      );
    } catch (error) {
      console.error('Error reading dictionary directory:', error);
      return [];
    }
  }

  /**
   * Bundle all translations
   */
  async bundleTranslations(): Promise<void> {
    console.log('ðŸ”„ [Translation Bundler] Bundling all translations...');
    
    // Ensure output directory exists
    if (!fs.existsSync(this.outputDir)) {
      fs.mkdirSync(this.outputDir, { recursive: true });
    }

    // Refresh locales list
    this.locales = this.getAvailableLocales();

    if (this.locales.length === 0) {
      console.warn('No locales found in dictionary directory');
      return;
    }

    // Bundle each locale
    for (const locale of this.locales) {
      await this.bundleLocale(locale);
    }

    // Generate index file
    await this.generateIndex();

    console.log('âœ… [Translation Bundler] All translations bundled successfully');
  }

  /**
   * Bundle translations for a specific locale
   */
  private async bundleLocale(locale: string): Promise<void> {
    const localeDir = path.join(this.dictionaryDir, locale);
    
    if (!fs.existsSync(localeDir)) {
      console.warn(`No translations directory found for locale: ${locale}`);
      return;
    }

    try {
      const messages = this.loadNestedMessages(localeDir);
      const outputFile = path.join(this.outputDir, `${locale}.json`);
      
      await fs.promises.writeFile(outputFile, JSON.stringify(messages, null, 2), 'utf8');
      console.log(`âœ… [Translation Bundler] Generated bundle for ${locale}`);
    } catch (error) {
      console.error(`Error bundling messages for locale ${locale}:`, error);
      throw error;
    }
  }

  /**
   * Recursively loads JSON files from a directory structure into a nested object
   */
  private loadNestedMessages(dir: string): Record<string, any> {
    const result: Record<string, any> = {};
    
    try {
      const items = fs.readdirSync(dir, { withFileTypes: true });
      
      for (const item of items) {
        const itemPath = path.join(dir, item.name);
        
        if (item.isDirectory()) {
          result[item.name] = this.loadNestedMessages(itemPath);
        } else if (item.isFile() && item.name.endsWith('.json')) {
          const key = item.name.replace('.json', '');
          try {
            const content = fs.readFileSync(itemPath, 'utf8');
            result[key] = JSON.parse(content);
          } catch (error) {
            console.error(`Error loading translation file ${itemPath}:`, error);
          }
        }
      }
      
      return result;
    } catch (error) {
      console.error(`Error reading directory ${dir}:`, error);
      return {};
    }
  }

  /**
   * Generate an index.ts file that exports all bundled translations
   */
  private async generateIndex(): Promise<void> {
    let content = `// GENERATED FILE - DO NOT EDIT MANUALLY
// This file is automatically generated from the translations in the 'dictionary' directory

// Import bundled translations
`;

    this.locales.forEach(locale => {
      content += `import ${locale}Messages from './${locale}.json';\n`;
    });

    content += `
import { Translations } from '../generated-types';

/**
 * Maps of locale codes to their pre-bundled translations
 */
const BUNDLED_TRANSLATIONS: Record<string, Translations> = {
${this.locales.map(locale => `  '${locale}': ${locale}Messages as unknown as Translations`).join(',\n')}
};

export default BUNDLED_TRANSLATIONS;
`;

    const indexFile = path.join(this.outputDir, 'index.ts');
    await fs.promises.writeFile(indexFile, content, 'utf8');
    console.log('âœ… [Translation Bundler] Generated index.ts');
  }

  /**
   * Get list of translation files for cache key generation
   */
  getTranslationFiles(): string[] {
    const files: string[] = [];

    const scanDirectory = (dir: string) => {
      try {
        const items = fs.readdirSync(dir, { withFileTypes: true });
        
        for (const item of items) {
          const itemPath = path.join(dir, item.name);
          
          if (item.isDirectory()) {
            scanDirectory(itemPath);
          } else if (item.isFile() && item.name.endsWith('.json')) {
            files.push(itemPath);
          }
        }
      } catch (error) {
        // Ignore errors for missing directories
      }
    };

    for (const locale of this.locales) {
      const localeDir = path.join(this.dictionaryDir, locale);
      scanDirectory(localeDir);
    }

    return files;
  }

  /**
   * Get available locales
   */
  getLocales(): string[] {
    return this.locales;
  }
}
