/**
 * Translation Types Generator
 *
 * Generates TypeScript type definitions for translation messages.
 * This analyzes ALL translation files across ALL locales in the dictionary directory
 * and generates comprehensive TypeScript interfaces that include the union of all
 * translation keys from all languages, ensuring complete type safety.
 */

import * as fs from 'fs';
import * as path from 'path';

export class TranslationTypesGenerator {
  private dictionaryDir: string;
  private outputFile: string;

  constructor(dictionaryDir: string, _defaultLocale: string, outputFile: string) {
    this.dictionaryDir = dictionaryDir;
    // _defaultLocale parameter kept for backward compatibility but not used
    // since we now process all locales to generate comprehensive types
    this.outputFile = outputFile;
  }

  /**
   * Generate TypeScript types for translations
   */
  async generateTypes(): Promise<void> {
    console.log('üîÑ [Translation Types] Generating translation types...');

    try {
      // Ensure dictionary directory exists
      if (!fs.existsSync(this.dictionaryDir)) {
        console.error(`Dictionary directory not found: ${this.dictionaryDir}`);
        return;
      }

      // Get all available locales
      const locales = this.getAvailableLocales();
      if (locales.length === 0) {
        console.error('No locales found in dictionary directory');
        return;
      }

      // Process all locales and merge their structures
      const translationsStructure = this.mergeAllLocaleStructures(locales);

      // Generate the TypeScript content
      const typeContent = this.generateTypeContent(translationsStructure);

      // Ensure output directory exists
      const outputDir = path.dirname(this.outputFile);
      if (!fs.existsSync(outputDir)) {
        fs.mkdirSync(outputDir, { recursive: true });
      }

      // Write the output file
      await fs.promises.writeFile(this.outputFile, typeContent, 'utf8');
      console.log(`‚úÖ [Translation Types] Types written to: ${this.outputFile}`);

    } catch (error) {
      console.error('‚ùå [Translation Types] Error generating types:', error);
      throw error;
    }
  }

  /**
   * Process a directory and return its structure
   */
  private processDirectory(dir: string): Record<string, any> {
    const categoryInterfaces: Record<string, any> = {};

    try {
      const items = fs.readdirSync(dir, { withFileTypes: true });

      for (const item of items) {
        if (item.isDirectory()) {
          const subDir = path.join(dir, item.name);
          const category = item.name;
          categoryInterfaces[category] = this.processDirectory(subDir);
        } else if (item.isFile() && item.name.endsWith('.json')) {
          try {
            const content = fs.readFileSync(path.join(dir, item.name), 'utf8');
            const namespaceName = path.basename(item.name, '.json');
            categoryInterfaces[namespaceName] = JSON.parse(content);
          } catch (error) {
            console.error(`Error processing ${path.join(dir, item.name)}: ${error}`);
          }
        }
      }

      return categoryInterfaces;
    } catch (error) {
      console.error(`Error reading directory ${dir}:`, error);
      return {};
    }
  }

  /**
   * Generate the complete TypeScript content
   */
  private generateTypeContent(translationsStructure: Record<string, any>): string {
    let output = `// GENERATED FILE - DO NOT EDIT MANUALLY\n`;
    output += `// This file is automatically generated from the translations in the 'dictionary' directory\n\n`;

    // Generate the main Translations interface
    output += `export interface Translations {\n`;
    for (const [category, content] of Object.entries(translationsStructure)) {
      output += `  ${category}: {\n`;
      for (const namespace of Object.keys(content)) {
        const interfaceName = `${this.capitalize(category)}${this.capitalize(namespace)}Translations`;
        output += `    ${namespace}: ${interfaceName};\n`;
      }
      output += `  };\n`;
    }
    output += `}\n\n`;

    // Generate all the individual interfaces
    for (const [category, categoryContent] of Object.entries(translationsStructure)) {
      for (const [namespace, content] of Object.entries(categoryContent)) {
        const interfaceName = `${this.capitalize(category)}${this.capitalize(namespace)}Translations`;

        // Generate the main interface
        output += this.objectToInterface(content, interfaceName);

        // Generate all nested interfaces
        const nestedInterfaces = this.getAllNestedInterfaces(content, interfaceName);
        for (const [nestedName, nestedContent] of Object.entries(nestedInterfaces)) {
          output += this.objectToInterface(nestedContent, nestedName);
        }
      }
    }

    // Generate TranslationNamespace type
    output += `// Type for translation namespaces\n`;
    output += `export type TranslationNamespace = \n`;

    const namespaces = [];
    for (const [category, categoryContent] of Object.entries(translationsStructure)) {
      for (const namespace of Object.keys(categoryContent)) {
        namespaces.push(`  | "${category}.${namespace}"`);
      }
    }

    output += namespaces.join('\n');
    output += `;\n`;

    return output;
  }

  /**
   * Convert an object to a TypeScript interface
   */
  private objectToInterface(obj: any, interfaceName: string): string {
    let output = `export interface ${interfaceName} {\n`;

    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'string') {
        output += `  ${key}: string;\n`;
      } else if (typeof value === 'object' && value !== null) {
        const nestedInterfaceName = `${interfaceName}${this.capitalize(key)}`;
        output += `  ${key}: ${nestedInterfaceName};\n`;
      }
    }

    output += `}\n\n`;
    return output;
  }

  /**
   * Get all nested interfaces from an object
   */
  private getAllNestedInterfaces(obj: any, parentName: string): Record<string, any> {
    const interfaces: Record<string, any> = {};

    for (const [key, value] of Object.entries(obj)) {
      if (typeof value === 'object' && value !== null) {
        const interfaceName = `${parentName}${this.capitalize(key)}`;
        interfaces[interfaceName] = value;

        // Recursively get nested interfaces
        const nestedInterfaces = this.getAllNestedInterfaces(value, interfaceName);
        Object.assign(interfaces, nestedInterfaces);
      }
    }

    return interfaces;
  }

  /**
   * Get list of available locales from dictionary directory
   */
  private getAvailableLocales(): string[] {
    try {
      return fs.readdirSync(this.dictionaryDir).filter(item =>
        fs.statSync(path.join(this.dictionaryDir, item)).isDirectory()
      );
    } catch (error) {
      console.error('Error reading dictionary directory:', error);
      return [];
    }
  }

  /**
   * Merge translation structures from all locales to create a comprehensive type definition
   */
  private mergeAllLocaleStructures(locales: string[]): Record<string, any> {
    const mergedStructure: Record<string, any> = {};

    console.log(`üîÑ [Translation Types] Processing ${locales.length} locales: ${locales.join(', ')}`);

    for (const locale of locales) {
      const localePath = path.join(this.dictionaryDir, locale);
      if (fs.existsSync(localePath)) {
        const localeStructure = this.processDirectory(localePath);
        this.deepMergeStructures(mergedStructure, localeStructure);
      }
    }

    return mergedStructure;
  }

  /**
   * Deep merge two translation structures, ensuring all keys from all locales are included
   */
  private deepMergeStructures(target: Record<string, any>, source: Record<string, any>): void {
    for (const [key, value] of Object.entries(source)) {
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        // If the key doesn't exist in target, create it
        if (!target[key] || typeof target[key] !== 'object') {
          target[key] = {};
        }
        // Recursively merge nested objects
        this.deepMergeStructures(target[key], value);
      } else {
        // For primitive values, just ensure the key exists
        // We don't overwrite existing values, we just ensure the key structure exists
        if (!target.hasOwnProperty(key)) {
          target[key] = value;
        }
      }
    }
  }

  /**
   * Capitalize the first letter of a string
   */
  private capitalize(str: string): string {
    return str.charAt(0).toUpperCase() + str.slice(1);
  }
}
